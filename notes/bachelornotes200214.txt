Kenneths svar:
> Heruder er svar på spørgsmål fra mig.
>
> out-of-band:
> Som jeg forstår det, så handler det om at undgå kopiering af data. Man sender i princippet bare en pointer rundt. Så hvis man internt i et program pickler/unpickler så kan man få det oprindeligt objekt tilbage. Det tror jeg ikke er super relevant for jer, fordi I vil have en ny instans af programmet, så det bliver en kopi af den oprindelige tilstand alligevel. Det er muligvis hurtigere, selv I dette scenarie, at bruge custom buffers.
>
> Grad af implementering:
> I må bruge hvad som helst I kan finde!
> Det er sådan at I får “point” (og point => karakter) efter hvad I selv har udført af arbejde. Men der er ikke grund til at re-implementere noget der allerede virker godt. Hvis I kan argumentere for at et eksisterende bibliotek virker godt, så brug endeligt det.
> Eneste betænkning er at det er svært at skrive en god opgave med “Jeg brugte bare bibliotek xx og så var jeg færdig”. Men hvis en anden løsning er bedre end jeres, så er det bare at lave benchmarks og vise at det eksisterende er bedre (eller “godt nok”). Det er OK at rapportere at I ikke kan outperforme andre, hvis bare det er godt dokumenteret (mao: negative resultater tæller ikke ned i karakter).
>
> Resume:
> Jeg tror ikke man kan få Python til at “hoppe” til en vilkårlig linje i programmet. Men det er OK, fordi I skal bare kunne fortsætte fra sidste snapshot.
> Jeg forestiller mig en simpel første udgave hvor man har en funktion ala:
>
> def run_iteration(round):
>    …
>
> Og så er jeres bibliotek noget ala:
>
> round, rounds = snapshot_library.start_or_resume(round_count=1000)
> snapshot_library.run_rounds(round, rounds, run_iteration)
>
> Altså, man skal på en eller anden måde finde ud af om man starter på ny, eller fortsætter fra et gemt snapshot.
> Herefter skal man kalde en bestemt funktion et antal gange (`run_rounds()` kalder `run_iteration()` i `xrange(round, rounds)`).
> Implementationen af `run_rounds()` er i pseudokode noget ala:
>
> def run_rounds(start, count, method):
>    for n in xrange(start, count):
>      snapshot()
>      method(n)
>
> Det er muligt at I også skal kræve at “init” er en funktion, sådan at `start_or_resume()` kan enten kalde `init()` eller indlæse state.
>
> I den skitserede løsning lægger man meget arbejde over på brugeren af biblioteket, fordi denne skal sikre at `run_iteration()` kan køre med kun et runde nummer.
> Det er let for noget som HeatEquation, men kan måske forfines senere.
>   
>
> Mvh. Kenneth

----------------------------------------------------------

det er programmørens ansvar at holde styr på hvor i programmet man skal "stoppe" og opstarte igen. 

Programmøren skal selv aktivt sige hvor de vil checkpointe.

Når vi skal skrive rapport, skal vi også sammenligne med andre: e.g dill.

Det er en god konkurrent at måle med, så kan vi sammenligne vores egen med dill.

Opsumering:

Kig på benchmark igen. stop sesseion, load session - få de samme resultater som hvis man bare havde kørt den uden at stoppe. 

udvid pickle pakken med vores eget "modul" således at vi i hvert fald kan håndtere numpy typer. 

Vi skal huske at være kritiske (hvis man eg. får for gode resultater til at starte).
Husk at være i stand til at forklare resultaterne, hvis de fx er gode - hvorfor er de så gode. 

----------------------------------------------------------

Start simpelt: Gør det til en constraint at programmøren skal lave et sted hvor det er oplagt at checkpointe og strukturere programmet således at man kan fortsætte fra et checkpoint på en nem måde.

Mulig fremtidig implementering: Hijack AST træet som bliver brugt til at interprete programmet og lav noget fancy så vi kan genoptage programmet i stedet for at kræve at programmøren strukturerer det på en bestemt måde.

Til nu: Omskriv benchmark.py til at køre x interationer, gemme og stoppe, og så kunne starte op igen fra et checkpoint og køre videre. Godt til at teste mod vores løsning. Brug bare dill her.


Foreløbigt end goal:
	Byg videre på pickle så den virker (lidt ala dill) så det kan virke som dill og gemme hele programmet fejlfrit. fx ekstra typer og nestede funktioner mm..